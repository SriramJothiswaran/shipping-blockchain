{
  "_args": [
    [
      {
        "raw": "protobufjs@6.6.3",
        "scope": null,
        "escapedName": "protobufjs",
        "name": "protobufjs",
        "rawSpec": "6.6.3",
        "spec": "6.6.3",
        "type": "version"
      },
      "/Users/sriram/fabric-tools/perishable-network/node_modules/composer-common"
    ]
  ],
  "_from": "protobufjs@6.6.3",
  "_id": "protobufjs@6.6.3",
  "_inCache": true,
  "_location": "/protobufjs",
  "_nodeVersion": "6.9.1",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/protobufjs-6.6.3.tgz_1485820618710_0.9740805926267058"
  },
  "_npmUser": {
    "name": "dcode",
    "email": "dcode+npm@dcode.io"
  },
  "_npmVersion": "4.0.5",
  "_phantomChildren": {},
  "_requested": {
    "raw": "protobufjs@6.6.3",
    "scope": null,
    "escapedName": "protobufjs",
    "name": "protobufjs",
    "rawSpec": "6.6.3",
    "spec": "6.6.3",
    "type": "version"
  },
  "_requiredBy": [
    "/composer-common"
  ],
  "_resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.6.3.tgz",
  "_shasum": "ee7388dd945e810ce738dcb65bfd09fa47aa4993",
  "_shrinkwrap": null,
  "_spec": "protobufjs@6.6.3",
  "_where": "/Users/sriram/fabric-tools/perishable-network/node_modules/composer-common",
  "author": {
    "name": "Daniel Wirtz",
    "email": "dcode+protobufjs@dcode.io"
  },
  "bin": {
    "pbjs": "bin/pbjs",
    "pbts": "bin/pbts"
  },
  "bugs": {
    "url": "https://github.com/dcodeIO/protobuf.js/issues"
  },
  "cliDependencies": [
    "semver",
    "chalk",
    "glob",
    "jsdoc",
    "minimist",
    "tmp",
    "uglify-js",
    "esprima",
    "escodegen",
    "estraverse"
  ],
  "dependencies": {
    "@protobufjs/aspromise": "^1.1.1",
    "@protobufjs/base64": "^1.1.1",
    "@protobufjs/codegen": "^1.0.8",
    "@protobufjs/eventemitter": "^1.1.0",
    "@protobufjs/fetch": "^1.1.0",
    "@protobufjs/inquire": "^1.1.0",
    "@protobufjs/path": "^1.1.1",
    "@protobufjs/pool": "^1.1.0",
    "@protobufjs/utf8": "^1.1.0",
    "@types/long": "^3.0.31",
    "@types/node": "7.0.4",
    "long": "^3.2.0"
  },
  "description": "Protocol Buffers for JavaScript (& TypeScript).",
  "devDependencies": {
    "benchmark": "^2.1.3",
    "browserify": "^14.0.0",
    "browserify-wrap": "^1.0.2",
    "bundle-collapser": "^1.2.1",
    "chalk": "^1.1.3",
    "coveralls": "^2.11.15",
    "escodegen": "^1.8.1",
    "eslint": "^3.14.1",
    "esprima": "^3.1.3",
    "estraverse": "^4.2.0",
    "gh-pages": "^0.12.0",
    "git-raw-commits": "^1.1.2",
    "git-semver-tags": "^1.1.2",
    "glob": "^7.1.1",
    "gulp": "^3.9.1",
    "gulp-header": "^1.8.8",
    "gulp-if": "^2.0.1",
    "gulp-sourcemaps": "^2.4.0",
    "gulp-uglify": "^2.0.1",
    "istanbul": "^0.4.5",
    "jaguarjs-jsdoc": "github:dcodeIO/jaguarjs-jsdoc",
    "jsdoc": "^3.4.2",
    "minimist": "^1.2.0",
    "node-zopfli": "^2.0.2",
    "semver": "^5.3.0",
    "tap-spec": "^4.1.1",
    "tape": "^4.6.3",
    "tmp": "0.0.31",
    "typescript": "^2.1.5",
    "uglify-js": "^2.7.5",
    "vinyl-buffer": "^1.0.0",
    "vinyl-fs": "^2.4.4",
    "vinyl-source-stream": "^1.1.0",
    "zuul": "^3.11.1",
    "zuul-ngrok": "^4.0.0"
  },
  "directories": {},
  "dist": {
    "shasum": "ee7388dd945e810ce738dcb65bfd09fa47aa4993",
    "tarball": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.6.3.tgz"
  },
  "gitHead": "5909f844a32c9810f6b35de821aa4220554d3fe2",
  "homepage": "http://dcode.io/protobuf.js",
  "keywords": [
    "protobuf",
    "protocol",
    "buffers",
    "protocol buffers",
    "serialization",
    "encoding"
  ],
  "license": "BSD-3-Clause",
  "main": "index.js",
  "maintainers": [
    {
      "name": "dcode",
      "email": "dcode@dcode.io"
    }
  ],
  "name": "protobufjs",
  "optionalDependencies": {
    "@types/long": "^3.0.31",
    "long": "^3.2.0"
  },
  "readme": "<h1><p align=\"center\"><img alt=\"protobuf.js\" src=\"https://github.com/dcodeIO/protobuf.js/raw/master/pbjs.png\" width=\"120\" height=\"104\" /></p></h1>\r\n<p align=\"center\"><a href=\"https://travis-ci.org/dcodeIO/protobuf.js\"><img src=\"https://travis-ci.org/dcodeIO/protobuf.js.svg?branch=master\" alt=\"\"></a> <a href=\"https://coveralls.io/github/dcodeIO/protobuf.js\"><img src=\"https://coveralls.io/repos/github/dcodeIO/protobuf.js/badge.svg?branch=master\" alt=\"\"></a> <a href=\"https://npmjs.org/package/protobufjs\"><img src=\"https://img.shields.io/npm/v/protobufjs.svg\" alt=\"\"></a> <a href=\"https://npmjs.org/package/protobufjs\"><img src=\"https://img.shields.io/npm/dm/protobufjs.svg\" alt=\"\"></a> <a href=\"https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=dcode%40dcode.io&item_name=Open%20Source%20Software%20Donation&item_number=dcodeIO%2Fprotobuf.js\"><img alt=\"donate ❤\" src=\"https://img.shields.io/badge/donate-❤-ff2244.svg\"></a></p>\r\n\r\n**Protocol Buffers** are a language-neutral, platform-neutral, extensible way of serializing structured data for use in communications protocols, data storage, and more, originally designed at Google ([see](https://developers.google.com/protocol-buffers/)).\r\n\r\n**protobuf.js** is a pure JavaScript implementation with TypeScript support for node and the browser. It's super easy to use, blazingly fast and works out of the box on .proto files!\r\n\r\nContents\r\n--------\r\n\r\n* [Usage](#usage)<br />\r\n  How to include protobuf.js in your project.\r\n\r\n* [Distributions](#distributions)<br />\r\n  A brief introduction to the available distributions and their use cases.\r\n\r\n* [Examples](#examples)<br />\r\n  A few examples to get you started.\r\n\r\n* [Documentation](#documentation)<br />\r\n  A list of available documentation resources.\r\n\r\n* [Command line](#command-line)<br />\r\n  How to use the command line utility.\r\n\r\n* [Performance](#performance)<br />\r\n  A few internals and a benchmark on performance.\r\n\r\n* [Compatibility](#compatibility)<br />\r\n  Notes on compatibility regarding browsers and optional libraries.\r\n\r\n* [Building](#building)<br />\r\n  How to build the library and its components yourself.\r\n\r\nUsage\r\n---------------\r\n\r\n### node.js\r\n\r\n```\r\n$> npm install protobufjs [--save --save-prefix=~]\r\n```\r\n\r\n```js\r\nvar protobuf = require(\"protobufjs\");\r\n```\r\n\r\n### Browsers\r\n\r\nDevelopment:\r\n```\r\n<script src=\"//cdn.rawgit.com/dcodeIO/protobuf.js/6.X.X/dist/protobuf.js\"></script>\r\n```\r\n\r\nProduction:\r\n```\r\n<script src=\"//cdn.rawgit.com/dcodeIO/protobuf.js/6.X.X/dist/protobuf.min.js\"></script>\r\n```\r\n\r\n**NOTE:** Remember to replace the version tag with the exact [release](https://github.com/dcodeIO/protobuf.js/tags) your project depends upon.\r\n\r\nThe `protobuf` namespace will always be available globally / also supports AMD loaders.\r\n\r\nDistributions\r\n-------------\r\n\r\nThe library supports both reflection-based and code-based use cases:\r\n\r\n1. Parsing protocol buffer definitions (.proto files) to reflection\r\n2. Loading JSON descriptors to reflection\r\n3. Generating static code without any reflection features\r\n\r\nThere is a suitable distribution for each of these:\r\n\r\n|         | Gzipped | Downloads                    | How to require                  | Description\r\n|---------|---------|------------------------------|---------------------------------|-------------\r\n| full    | 18.5kb  | [dist][dist-full]            | `require(\"protobufjs\")`         | All features. Works with everything.\r\n| light   | 15.5kb  | [dist/light][dist-light]     | `require(\"protobufjs/light\")`   | All features except tokenizer, parser and bundled common types. Works with JSON definitions, pure reflection and static code.\r\n| minimal | 6.0kb+  | [dist/minimal][dist-minimal] | `require(\"protobufjs/minimal\")` | Just enough to run static code. No reflection.\r\n\r\nIn case of doubt you can just use the full library.\r\n\r\n[dist-full]: https://github.com/dcodeIO/protobuf.js/tree/master/dist\r\n[dist-light]: https://github.com/dcodeIO/protobuf.js/tree/master/dist/light\r\n[dist-minimal]: https://github.com/dcodeIO/protobuf.js/tree/master/dist/minimal\r\n\r\nExamples\r\n--------\r\n\r\n### Using .proto files\r\n\r\nIt's possible to load existing .proto files using the full library, which parses and compiles the definitions to ready to use (reflection-based) message classes:\r\n\r\n```protobuf\r\n// awesome.proto\r\npackage awesomepackage;\r\nsyntax = \"proto3\";\r\n\r\nmessage AwesomeMessage {\r\n    string awesome_field = 1; // becomes awesomeField\r\n}\r\n```\r\n\r\n```js\r\nprotobuf.load(\"awesome.proto\", function(err, root) {\r\n    if (err) throw err;\r\n\r\n    // Obtain a message type\r\n    var AwesomeMessage = root.lookup(\"awesomepackage.AwesomeMessage\");\r\n\r\n    // Create a new message\r\n    var message = AwesomeMessage.create({ awesomeField: \"AwesomeString\" });\r\n\r\n    // Encode a message\r\n    var buffer = AwesomeMessage.encode(message).finish();\r\n    // ... do something with buffer\r\n\r\n    // Or, encode a plain object\r\n    var buffer = AwesomeMessage.encode({ awesomeField: \"AwesomeString\" }).finish();\r\n    // ... do something with buffer\r\n\r\n    // Decode a buffer\r\n    var message = AwesomeMessage.decode(buffer);\r\n    // ... do something with message\r\n\r\n    // If your application uses length-delimited buffers, there is also encodeDelimited and decodeDelimited.\r\n});\r\n```\r\n\r\nYou can also use promises by omitting the callback:\r\n\r\n```js\r\nprotobuf.load(\"awesome.proto\")\r\n    .then(function(root) {\r\n       ...\r\n    });\r\n```\r\n\r\n### Using JSON descriptors\r\n\r\nThe library utilizes a JSON format that is equivalent to a .proto definition (see also: [Command line usage](#command-line)).\r\n\r\nThe following is identical to the .proto definition seen above, but it can also be used with just the light library because it doesn't require the parser:\r\n\r\n```json\r\n// awesome.json\r\n{\r\n  \"nested\": {\r\n    \"AwesomeMessage\": {\r\n      \"fields\": {\r\n        \"awesomeField\": {\r\n          \"type\": \"string\",\r\n          \"id\": 1\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nA JSON descriptor can either be loaded the usual way:\r\n\r\n```js\r\nprotobuf.load(\"awesome.json\", function(err, root) {\r\n    if (err) throw err;\r\n\r\n    // Continue at \"Obtain a message type\" above\r\n});\r\n```\r\n\r\nOr you can load it inline:\r\n\r\n```js\r\nvar jsonDescriptor = require(\"./awesome.json\"); // exemplary for node\r\n\r\nvar root = protobuf.Root.fromJSON(jsonDescriptor);\r\n\r\n// Continue at \"Obtain a message type\" above\r\n```\r\n\r\n### Using reflection only\r\n\r\nBoth the full and the light library include full reflection support. You could, for example, define the .proto definitions seen in the examples above using just reflection:\r\n\r\n```js\r\n...\r\nvar Root  = protobuf.Root,\r\n    Type  = protobuf.Type,\r\n    Field = protobuf.Field;\r\n\r\nvar AwesomeMessage = new Type(\"AwesomeMessage\").add(new Field(\"awesomeField\", 1, \"string\"));\r\n\r\nvar root = new Root().define(\"awesomepackage\").add(AwesomeMessage);\r\n\r\n// Continue at \"Create a new message\" above\r\n...\r\n```\r\n\r\nDetailed information on the reflection structure is available within the [documentation](#documentation).\r\n\r\n### Using custom classes\r\n\r\nYou can also extend runtime message classes with your own custom functionality by registering your own class with a reflected message type:\r\n\r\n```js\r\n...\r\n\r\n// Define your own prototypal class\r\nfunction AwesomeMessage(properties) {\r\n    protobuf.Message.call(this, properties); // call the super constructor\r\n}\r\n\r\n// Register your custom class with its reflected type (*)\r\nprotobuf.Class.create(root.lookup(\"awesomepackage.AwesomeMessage\") /* or use reflection */, AwesomeMessage);\r\n\r\n// Define your custom functionality\r\nAwesomeMessage.customStaticMethod = function() { ... };\r\nAwesomeMessage.prototype.customInstanceMethod = function() { ... };\r\n\r\n// Continue at \"Create a message\" above (you can also use the constructor directly)\r\n```\r\n\r\n(*) Besides referencing its reflected type through `AwesomeMessage.$type` and `AwesomeMesage#$type`, the respective custom class is automatically populated with:\r\n\r\n* `AwesomeMessage.create`\r\n* `AwesomeMessage.encode` and `AwesomeMessage.encodeDelimited`\r\n* `AwesomeMessage.decode` and `AwesomeMessage.decodeDelimited`\r\n* `AwesomeMessage.verify`\r\n* `AwesomeMessage.fromObject`, `AwesomeMessage.toObject`, `AwesomeMessage#toObject` and `AwesomeMessage#toJSON`\r\n\r\n### Using services\r\n\r\nThe library also supports services but it doesn't make any assumptions about the actual transport channel. Instead, a user must provide a suitable RPC implementation, which is an asynchronous function that takes the reflected service method, the binary request and a node-style callback as its parameters:\r\n\r\n```js\r\nfunction rpcImpl(method, requestData, callback) {\r\n    // perform the request using an HTTP request or a WebSocket for example\r\n    var responseData = ...;\r\n    // and call the callback with the binary response afterwards:\r\n    callback(null, responseData);\r\n}\r\n```\r\n\r\nExample:\r\n\r\n```protobuf\r\n// greeter.proto\r\nsyntax = \"proto3\";\r\n\r\nservice Greeter {\r\n    rpc SayHello (HelloRequest) returns (HelloReply) {}\r\n}\r\n\r\nmessage HelloRequest {\r\n    string name = 1;\r\n}\r\n\r\nmessage HelloReply {\r\n    string message = 1;\r\n}\r\n```\r\n\r\n```js\r\n...\r\nvar Greeter = root.lookup(\"Greeter\");\r\nvar greeter = Greeter.create(/* see above */ rpcImpl, /* request delimited? */ false, /* response delimited? */ false);\r\n\r\ngreeter.sayHello({ name: 'you' }, function(err, response) {\r\n    console.log('Greeting:', response.message);\r\n});\r\n```\r\n\r\nServices also support promises:\r\n\r\n```js\r\ngreeter.sayHello({ name: 'you' })\r\n    .then(function(response) {\r\n        console.log('Greeting:', response.message);\r\n    });\r\n```\r\n\r\nThere is also an [example for streaming RPC](https://github.com/dcodeIO/protobuf.js/blob/master/examples/streaming-rpc.js).\r\n\r\n### Usage with TypeScript\r\n\r\nThe library ships with its own [type definitions](https://github.com/dcodeIO/protobuf.js/blob/master/index.d.ts) and modern editors like [Visual Studio Code](https://code.visualstudio.com/) should automatically detect and use them for code completion when following this pattern:\r\n\r\n```ts\r\n// node.js\r\nimport * as protobuf from \"protobufjs\";\r\nimport * as Long from \"long\"; // optional\r\n\r\n// browser only (alternatively)\r\nimport * as protobuf from \"./node_modules/protobufjs/index.js\";\r\nimport * as Long from \"./node_modules/long/dist/long.js\"; // optional\r\n\r\nprotobuf.load(\"awesome.proto\", function(err, root) {\r\n  if (err)\r\n    throw err;\r\n\r\n  // example code\r\n  var AwesomeMessage = root.lookupType(\"AwesomeMessage\");\r\n  var message = AwesomeMessage.create({ awesomeField: \"hello\" });\r\n  var buffer = AwesomeMessage.encode(message).finish();\r\n  ...\r\n});\r\n```\r\n\r\nTo achieve the same with static code generated by [pbjs](#command-line), there is the [pbts](#generating-typescript-definitions-from-static-modules) command line utility to generate type definitions from static code as well.\r\n\r\nLet's say you generated your static code to `bundle.js` and its type definitions to `bundle.d.ts`, then you can do:\r\n\r\n```ts\r\nimport * as root from \"./bundle.js\";\r\n\r\n// example code\r\nvar AwesomeMessage = root.AwesomeMessage;\r\nvar message = AwesomeMessage.create({ awesomeField: \"hello\" });\r\nvar buffer = AwesomeMessage.encode(message).finish();\r\n...\r\n```\r\n\r\nDocumentation\r\n-------------\r\n\r\n#### Protocol Buffers\r\n* [Google's Developer Guide](https://developers.google.com/protocol-buffers/docs/overview)\r\n\r\n#### protobuf.js\r\n* [API Documentation](http://dcode.io/protobuf.js)\r\n* [CHANGELOG](https://github.com/dcodeIO/protobuf.js/blob/master/CHANGELOG.md)\r\n* [Frequently asked questions](https://github.com/dcodeIO/protobuf.js/wiki) on our wiki\r\n\r\n#### Community\r\n* [Questions and answers](http://stackoverflow.com/questions/tagged/protobuf.js) on StackOverflow\r\n\r\nCommand line\r\n------------\r\n\r\nThe `pbjs` command line utility can be used to bundle and translate between .proto and .json files. It also generates static code.\r\n\r\n```\r\nConsolidates imports and converts between file formats.\r\n\r\n  -t, --target    Specifies the target format. Also accepts a path to require a custom target.\r\n\r\n                  json          JSON representation\r\n                  json-module   JSON representation as a module\r\n                  proto2        Protocol Buffers, Version 2\r\n                  proto3        Protocol Buffers, Version 3\r\n                  static        Static code without reflection\r\n                  static-module Static code without reflection as a module\r\n\r\n  -p, --path      Adds a directory to the include path.\r\n\r\n  -o, --out       Saves to a file instead of writing to stdout.\r\n\r\n  Module targets only:\r\n\r\n  -w, --wrap      Specifies the wrapper to use. Also accepts a path to require a custom wrapper.\r\n\r\n                  default   Default wrapper supporting both CommonJS and AMD\r\n                  commonjs  CommonJS wrapper\r\n                  amd       AMD wrapper\r\n                  es6       ES6 wrapper (implies --es6)\r\n\r\n  -r, --root      Specifies an alternative protobuf.roots name.\r\n\r\n  -l, --lint      Linter configuration. Defaults to protobuf.js-compatible rules:\r\n\r\n                  eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins\r\n\r\n  --es6           Enables ES6 syntax (const/let instead of var)\r\n\r\n  Proto sources only:\r\n\r\n  --keep-case     Keeps field casing instead of converting to camel case.\r\n\r\n  Static targets only:\r\n\r\n  --no-create     Does not generate create functions used for reflection compatibility.\r\n  --no-encode     Does not generate encode functions.\r\n  --no-decode     Does not generate decode functions.\r\n  --no-verify     Does not generate verify functions.\r\n  --no-convert    Does not generate convert functions like from/toObject\r\n  --no-delimited  Does not generate delimited encode/decode functions.\r\n  --no-beautify   Does not beautify generated code.\r\n  --no-comments   Does not output any JSDoc comments.\r\n\r\nusage: pbjs [options] file1.proto file2.json ...  (or)  other | pbjs [options] -\r\n```\r\n\r\nFor production environments it is recommended to bundle all your .proto files to a single .json file, which reduces the number of network requests and parser invocations required:\r\n\r\n```\r\n$> pbjs -t json file1.proto file2.proto > bundle.json\r\n```\r\n\r\nNow, either include this file in your final bundle:\r\n\r\n```js\r\nvar root = protobuf.Root.fromJSON(require(\"./bundle.json\"));\r\n```\r\n\r\nor load it the usual way:\r\n\r\n```js\r\nprotobuf.load(\"bundle.json\", function(err, root) {\r\n    ...\r\n});\r\n```\r\n\r\nAs you might have noticed, `pbjs` is also capable of generating static code. For example\r\n\r\n```\r\n$> pbjs -t static-module -w commonjs -o compiled.js file1.proto file2.proto\r\n```\r\n\r\nwill generate static code for definitions within `file1.proto` and `file2.proto` to a CommonJS module `compiled.js`, which then can be used with just the [minimal library](#distributions).\r\n\r\n**ProTip!** Documenting your .proto files with `/** ... */`-blocks or (trailing) `/// ...` lines translates to generated static code.\r\n\r\n### Generating TypeScript definitions from static modules\r\n\r\nLikewise, the `pbts` command line utility can be used to generate TypeScript definitions from `pbjs`-generated static modules.\r\n\r\n```\r\nGenerates TypeScript definitions from annotated JavaScript files.\r\n\r\n  -o, --out       Saves to a file instead of writing to stdout.\r\n\r\n  -g, --global    Name of the global object in browser environments, if any.\r\n\r\n  --no-comments   Does not output any JSDoc comments.\r\n\r\n  Internal flags:\r\n\r\n  -n, --name      Wraps everything in a module of the specified name.\r\n\r\n  -m, --main      Whether building the main library without any imports.\r\n\r\nusage: pbts [options] file1.js file2.js ...  (or)  other | pbts [options] -\r\n```\r\n\r\nPicking up on the example above, the following not just generates static code to a CommonJS module `compiled.js` but also its respective TypeScript definitions to `compiled.d.ts`:\r\n\r\n```\r\n$> pbjs -t static-module -w commonjs -o compiled.js file1.proto file2.proto\r\n$> pbts -o compiled.d.ts compiled.js\r\n```\r\n\r\nAdditionally, TypeScript definitions of static modules are compatible with their reflection-based counterparts (i.e. as exported by JSON modules), as long as the following conditions are met:\r\n\r\n1. Instead of using `new SomeMessage(...)`, always use `SomeMessage.create(...)` because reflection objects do not provide a constructor.\r\n2. Types, services and enums must start with an uppercase letter to become available as properties of the reflected types as well (i.e. to be able to use `MyMessage.MyEnum` instead of `root.lookup(\"MyMessage.MyEnum\")`).\r\n\r\nFor example, the following generates a JSON module `bundle.js` and a `bundle.d.ts`, but no static code:\r\n\r\n```\r\n$> pbjs -t json-module -w commonjs -o bundle.js file1.proto file2.proto\r\n$> pbjs -t static-module file1.proto file2.proto | pbts -o bundle.d.ts -\r\n```\r\n\r\n### On reflection vs. static code\r\n\r\nWhile using .proto files directly requires the [full library](#distributions) respectively pure reflection/JSON the [light library](#distributions), pretty much all code but the relatively short descriptors is shared.\r\n\r\nStatic code, on the other hand, requires just the [minimal library](#distributions), but generates additional, albeit editable, source code without any reflection features.\r\n\r\nThere is no significant difference performance-wise as the code generated statically is pretty much the same as generated at runtime and both are largely interchangeable as seen in the previous section.\r\n\r\n### Using pbjs and pbts programmatically\r\n\r\nBoth utilities can be used programmatically by providing command line arguments and a callback to their respective `main` functions:\r\n\r\n```js\r\nvar pbjs = require(\"protobufjs/cli/pbjs\");\r\n\r\npbjs.main([ \"--target\", \"json-module\", \"path/to/myproto.proto\" ], function(err, output) {\r\n    if (err)\r\n        throw err;\r\n    // do something with output\r\n});\r\n```\r\n\r\nPerformance\r\n-----------\r\nThe package includes a benchmark that tries to compare performance to native JSON as far as this is possible. On an i7-2600K running node 6.9.1 it yields:\r\n\r\n```\r\nbenchmarking encoding performance ...\r\n\r\nType.encode to buffer x 547,361 ops/sec ±0.27% (94 runs sampled)\r\nJSON.stringify to string x 310,848 ops/sec ±0.73% (92 runs sampled)\r\nJSON.stringify to buffer x 173,608 ops/sec ±1.51% (86 runs sampled)\r\n\r\n      Type.encode to buffer was fastest\r\n   JSON.stringify to string was 43.5% slower\r\n   JSON.stringify to buffer was 68.7% slower\r\n\r\nbenchmarking decoding performance ...\r\n\r\nType.decode from buffer x 1,294,378 ops/sec ±0.86% (90 runs sampled)\r\nJSON.parse from string x 291,944 ops/sec ±0.72% (92 runs sampled)\r\nJSON.parse from buffer x 256,325 ops/sec ±1.50% (90 runs sampled)\r\n\r\n    Type.decode from buffer was fastest\r\n     JSON.parse from string was 77.4% slower\r\n     JSON.parse from buffer was 80.3% slower\r\n\r\nbenchmarking combined performance ...\r\n\r\nType to/from buffer x 254,126 ops/sec ±1.13% (91 runs sampled)\r\nJSON to/from string x 122,896 ops/sec ±1.29% (90 runs sampled)\r\nJSON to/from buffer x 88,005 ops/sec ±0.87% (89 runs sampled)\r\n\r\n        Type to/from buffer was fastest\r\n        JSON to/from string was 51.7% slower\r\n        JSON to/from buffer was 65.3% slower\r\n\r\nbenchmarking verifying performance ...\r\n\r\nType.verify x 6,246,765 ops/sec ±2.00% (87 runs sampled)\r\n\r\nbenchmarking message from object performance ...\r\n\r\nType.fromObject x 2,892,973 ops/sec ±0.70% (92 runs sampled)\r\n\r\nbenchmarking message to object performance ...\r\n\r\nType.toObject x 3,601,738 ops/sec ±0.72% (93 runs sampled)\r\n```\r\n\r\nNote that JSON is a native binding nowadays and as such is about as fast as it possibly can get. So, how can protobuf.js be faster?\r\n\r\n* The benchmark is [somewhat flawed](https://github.com/dcodeIO/protobuf.js/blob/master/bench/index.js).\r\n* Reader and writer interfaces configure themselves according to the environment to eliminate redundant conditionals.\r\n* Node-specific reader and writer subclasses benefit from node's buffer binding.\r\n* Reflection has built-in code generation that builds type-specific encoders, decoders and verifiers at runtime.\r\n* Encoders and decoders do not implicitly call `verify` on messages to avoid unnecessary overhead where messages are already known to be valid. It's up to the user to call `verify` where necessary.\r\n* Quite a bit of V8-specific profiling is accountable for everything else.\r\n\r\nYou can also run [the benchmark](https://github.com/dcodeIO/protobuf.js/blob/master/bench/index.js) ...\r\n\r\n```\r\n$> npm run bench\r\n```\r\n\r\nand [the profiler](https://github.com/dcodeIO/protobuf.js/blob/master/bench/prof.js) yourself (the latter requires a recent version of node):\r\n\r\n```\r\n$> npm run prof <encode|decode|encode-browser|decode-browser> [iterations=10000000]\r\n```\r\n\r\nNote that as of this writing, the benchmark suite performs significantly slower on node 7.2.0 compared to 6.9.1 because moths.\r\n\r\nCompatibility\r\n-------------\r\n\r\n[![Sauce Test Status](https://saucelabs.com/browser-matrix/protobuf.svg)](https://saucelabs.com/u/protobuf)\r\n\r\n* Because the internals of this package do not rely on `google/protobuf/descriptor.proto`, options are parsed and presented literally.\r\n* If typed arrays are not supported by the environment, plain arrays will be used instead.\r\n* Support for pre-ES5 environments (except IE8) can be achieved by [using a polyfill](https://github.com/dcodeIO/protobuf.js/blob/master/scripts/polyfill.js).\r\n* Support for [Content Security Policy](https://w3c.github.io/webappsec-csp/)-restricted environments (like Chrome extensions without [unsafe-eval](https://developer.chrome.com/extensions/contentSecurityPolicy#relaxing-eval)) can be achieved by generating and using static code instead.\r\n* If you need a proper way to work with 64 bit values (uint64, int64 etc.), you can install [long.js](https://github.com/dcodeIO/long.js) alongside this library. All 64 bit numbers will then be returned as a `Long` instance instead of a possibly unsafe JavaScript number ([see](https://github.com/dcodeIO/long.js)).\r\n\r\nBuilding\r\n--------\r\n\r\nTo build the library or its components yourself, clone it from GitHub and install the development dependencies:\r\n\r\n```\r\n$> git clone https://github.com/dcodeIO/protobuf.js.git\r\n$> cd protobuf.js\r\n$> npm install\r\n```\r\n\r\nBuilding the respective development and production versions with their respective source maps to `dist/`:\r\n\r\n```\r\n$> npm run build\r\n```\r\n\r\nBuilding the documentation to `docs/`:\r\n\r\n```\r\n$> npm run docs\r\n```\r\n\r\nBuilding the TypeScript definition to `index.d.ts`:\r\n\r\n```\r\n$> npm run types\r\n```\r\n\r\n### Browserify integration\r\n\r\nBy default, protobuf.js integrates into your browserify build-process without requiring any optional modules. Hence:\r\n\r\n* If you need int64 support, explicitly require the `long` module somewhere in your project as it will be excluded otherwise. This assumes that a global `require` function is present that protobuf.js can call to obtain the long module.\r\n\r\n  If there is no global `require` function present after bundling, it's also possible to assign the long module programmatically:\r\n\r\n  ```js\r\n  var Long = ...;\r\n  \r\n  protobuf.util.Long = Long;\r\n  protobuf.configure();\r\n  ```\r\n\r\n* If you have any special requirements, there is [the bundler](https://github.com/dcodeIO/protobuf.js/blob/master/scripts/bundle.js) for reference.\r\n\r\n**License:** [BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause)\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/dcodeIO/protobuf.js.git"
  },
  "scripts": {
    "bench": "node bench",
    "build": "gulp",
    "changelog": "node scripts/changelog -w",
    "coverage": "istanbul cover node_modules/tape/bin/tape tests/*.js tests/node/*.js",
    "coverage-ci": "npm run coverage && cat coverage/lcov.info | coveralls",
    "docs": "jsdoc -c jsdoc.docs.json -R README.md --verbose --pedantic",
    "lint": "eslint src",
    "make": "npm run test && npm run types && npm run build && npm run lint",
    "pages": "node scripts/pages",
    "postinstall": "node scripts/postinstall",
    "prepublish": "node scripts/prepublish",
    "prof": "node bench/prof",
    "release": "npm run make && npm run changelog",
    "test": "tape -r ./lib/tape-adapter tests/*.js tests/node/*.js | tap-spec",
    "types": "node bin/pbts --main --global protobuf --out index.d.ts src/ lib/aspromise/index.js lib/base64/index.js lib/codegen/index.js lib/eventemitter/index.js lib/fetch/index.js lib/inquire/index.js lib/path/index.js lib/pool/index.js lib/utf8/index.js && tsc tests/comp_typescript.ts --lib es2015 --noEmit --strictNullChecks && tsc tests/data/test.ts --lib es2015 --noEmit --strictNullChecks && tsc tests/data/rpc.ts --lib es2015 --noEmit --strictNullChecks",
    "zuul": "zuul --ui tape --no-coverage --concurrency 4 -- tests/*.js",
    "zuul-local": "zuul --ui tape --concurrency 1 --local 8080 --disable-tunnel -- tests/*.js"
  },
  "types": "index.d.ts",
  "version": "6.6.3",
  "versionScheme": "~"
}
